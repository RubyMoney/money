<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README

    &mdash; Documentation by YARD 0.9.37

</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">

    <a href="_index.html">Index</a> &raquo;
    <span class="title">File: README</span>

</div>

        <div id="search">

    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>

</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="rubymoney---money">RubyMoney - Money</h1>

<p><a href="https://rubygems.org/gems/money"><img src="https://badge.fury.io/rb/money.svg" alt="Gem Version" /></a>
<a href="https://github.com/RubyMoney/money/actions/workflows/ruby.yml"><img src="https://github.com/RubyMoney/money/actions/workflows/ruby.yml/badge.svg" alt="Ruby" /></a>
<a href="https://inch-ci.org/github/RubyMoney/money"><img src="https://inch-ci.org/github/RubyMoney/money.svg" alt="Inline docs" /></a>
<a href="https://opensource.org/license/MIT"><img src="https://img.shields.io/github/license/RubyMoney/money.svg" alt="License" /></a></p>

<p>⚠️ Please read the <a href="#migration-notes">migration notes</a> before upgrading to a new major version.</p>

<p>If you miss String parsing, check out the new <a href="https://github.com/RubyMoney/monetize">monetize gem</a>.</p>

<h2 id="contributing">Contributing</h2>

<p>See the <a href="https://github.com/RubyMoney/money/blob/main/CONTRIBUTING.md">Contribution Guidelines</a></p>

<h2 id="introduction">Introduction</h2>

<p>A Ruby Library for dealing with money and currency conversion.</p>

<h3 id="features">Features</h3>

<ul>
  <li>Provides a <code>Money</code> class which encapsulates all information about a certain
amount of money, such as its value and its currency.</li>
  <li>Provides a <code>Money::Currency</code> class which encapsulates all information about
a monetary unit.</li>
  <li>Represents monetary values as integers, in cents. This avoids floating point
rounding errors.</li>
  <li>Represents currency as <code>Money::Currency</code> instances providing a high level of
flexibility.</li>
  <li>Provides APIs for exchanging money from one currency to another.</li>
</ul>

<h3 id="resources">Resources</h3>

<ul>
  <li><a href="https://rubymoney.github.io/money/">Website</a></li>
  <li><a href="https://www.rubydoc.info/gems/money/frames">API Documentation</a></li>
  <li><a href="https://github.com/RubyMoney/money">Git Repository</a></li>
</ul>

<h3 id="notes">Notes</h3>

<ul>
  <li>Your app must use UTF-8 to function with this library. There are a
number of non-ASCII currency attributes.</li>
</ul>

<h2 id="downloading">Downloading</h2>

<p>Install stable releases with the following command:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='id identifier rubyid_install'>install</span> <span class='id identifier rubyid_money'>money</span>
</code></pre>

<p>The development version (hosted on Github) can be installed with:</p>

<pre class="code ruby"><code class="ruby">git clone git://github.com/RubyMoney/money.git
cd money
rake install
</code></pre>

<h2 id="usage">Usage</h2>

<p>```ruby
require ‘money’</p>

<h1 id="explicitly-define-locales">explicitly define locales</h1>
<p>I18n.config.available_locales = :en
Money.locale_backend = :i18n</p>

<h1 id="usd">10.00 USD</h1>
<p>money = Money.from_cents(1000, “USD”)
money.cents     #=&gt; 1000
money.currency  #=&gt; Currency.new(“USD”)</p>

<h1 id="comparisons">Comparisons</h1>
<p>Money.from_cents(1000, “USD”) == Money.from_cents(1000, “USD”)   #=&gt; true
Money.from_cents(1000, “USD”) == Money.from_cents(100, “USD”)    #=&gt; false
Money.from_cents(1000, “USD”) == Money.from_cents(1000, “EUR”)   #=&gt; false
Money.from_cents(1000, “USD”) != Money.from_cents(1000, “EUR”)   #=&gt; true</p>

<h1 id="arithmetic">Arithmetic</h1>
<p>Money.from_cents(1000, “USD”) + Money.from_cents(500, “USD”) == Money.from_cents(1500, “USD”)
Money.from_cents(1000, “USD”) - Money.from_cents(200, “USD”) == Money.from_cents(800, “USD”)
Money.from_cents(1000, “USD”) / 5                            == Money.from_cents(200, “USD”)
Money.from_cents(1000, “USD”) * 5                            == Money.from_cents(5000, “USD”)</p>

<h1 id="unit-to-subunit-conversions">Unit to subunit conversions</h1>
<p>Money.from_amount(5, “USD”) == Money.from_cents(500, “USD”)  # 5 USD
Money.from_amount(5, “JPY”) == Money.from_cents(5, “JPY”)    # 5 JPY
Money.from_amount(5, “TND”) == Money.from_cents(5000, “TND”) # 5 TND</p>

<h1 id="currency-conversions">Currency conversions</h1>
<p>some_code_to_setup_exchange_rates
Money.from_cents(1000, “USD”).exchange_to(“EUR”) == Money.from_cents(some_value, “EUR”)</p>

<h1 id="swap-currency">Swap currency</h1>
<p>Money.from_cents(1000, “USD”).with_currency(“EUR”) == Money.from_cents(1000, “EUR”)</p>

<h1 id="formatting-see-formatting-section-for-more-options">Formatting (see Formatting section for more options)</h1>
<p>Money.from_cents(100, “USD”).format #=&gt; “$1.00”
Money.from_cents(100, “GBP”).format #=&gt; “£1.00”
Money.from_cents(100, “EUR”).format #=&gt; “€1.00”
```</p>

<h2 id="currency">Currency</h2>

<p>Currencies are consistently represented as instances of <code>Money::Currency</code>.
The most part of <code>Money</code> APIs allows you to supply either a <code>String</code> or a
<code>Money::Currency</code>.</p>

<p><code>ruby
Money.from_cents(1000, "USD") == Money.from_cents(1000, Money::Currency.new("USD"))
Money.from_cents(1000, "EUR").currency == Money::Currency.new("EUR")
</code></p>

<p>A <code>Money::Currency</code> instance holds all the information about the currency,
including the currency symbol, name and much more.</p>

<p><code>ruby
currency = Money.from_cents(1000, "USD").currency
currency.iso_code     #=&gt; "USD"
currency.name         #=&gt; "United States Dollar"
currency.cents_based? #=&gt; true
</code></p>

<p>To define a new <code>Money::Currency</code> use <code>Money::Currency.register</code> as shown
below.</p>

<p>```ruby
curr = {
  priority:            1,
  iso_code:            “USD”,
  iso_numeric:         “840”,
  name:                “United States Dollar”,
  symbol:              “$”,
  subunit:             “Cent”,
  subunit_to_unit:     100,
  decimal_mark:        “.”,
  thousands_separator: “,”
}</p>

<p>Money::Currency.register(curr)
```</p>

<p>The pre-defined set of attributes includes:</p>

<ul>
  <li><code>:priority</code> a numerical value you can use to sort/group the currency list</li>
  <li><code>:iso_code</code> the international 3-letter code as defined by the ISO 4217 standard</li>
  <li><code>:iso_numeric</code> the international 3-digit code as defined by the ISO 4217 standard</li>
  <li><code>:name</code> the currency name</li>
  <li><code>:symbol</code> the currency symbol (UTF-8 encoded)</li>
  <li><code>:subunit</code> the name of the fractional monetary unit</li>
  <li><code>:subunit_to_unit</code> the proportion between the unit and the subunit</li>
  <li><code>:decimal_mark</code> character between the whole and fraction amounts</li>
  <li><code>:thousands_separator</code> character between each thousands place</li>
</ul>

<p>All attributes except <code>:iso_code</code> are optional. Some attributes, such as
<code>:symbol</code>, are used by the Money class to print out a representation of the
object. Other attributes, such as <code>:name</code> or <code>:priority</code>, exist to provide a
basic API you can take advantage of to build your application.</p>

<h3 id="priority">:priority</h3>

<p>The priority attribute is an arbitrary numerical value you can assign to the
<code>Money::Currency</code> and use in sorting/grouping operation.</p>

<p>For instance, let’s assume your Rails application needs to render a currency
selector like the one available
<a href="https://finance.yahoo.com/currency-converter/">here</a>. You can create a couple of
custom methods to return the list of major currencies and all currencies as
follows:</p>

<p>```ruby
# Returns an array of currency id where
# priority &lt; 10
def major_currencies(hash)
  hash.inject([]) do |array, (id, attributes)|
    priority = attributes[:priority]
    if priority &amp;&amp; priority &lt; 10
      array[priority] ||= []
      array[priority] « id
    end
    array
  end.compact.flatten
end</p>

<h1 id="returns-an-array-of-all-currency-id">Returns an array of all currency id</h1>
<p>def all_currencies(hash)
  hash.keys
end</p>

<p>major_currencies(Money::Currency.table)
# =&gt; [:usd, :eur, :gbp, :aud, :cad, :jpy]</p>

<p>all_currencies(Money::Currency.table)
# =&gt; [:aed, :afn, :all, …]
```</p>

<h3 id="default-currency">Default Currency</h3>

<p>A default currency is not set by default. If a default currency is not set, it will raise an error when you try to initialize a <code>Money</code> object without explicitly passing a currency or parse a string that does not contain a currency. You can set a default currency for your application by using:</p>

<p><code>ruby
Money.default_currency = Money::Currency.new("CAD")
</code></p>

<p>If you use <a href="https://github.com/RubyMoney/money/tree/main#ruby-on-rails">Rails</a>, then <code>config/initializers/money.rb</code> is a very good place to put this.</p>

<h3 id="currency-exponent">Currency Exponent</h3>

<p>The exponent of a money value is the number of digits after the decimal
separator (which separates the major unit from the minor unit). See e.g.
<a href="https://www.iso.org/iso-4217-currency-codes.html">ISO 4217</a> for more
information. You can find the exponent (as an <code>Integer</code>) by</p>

<p><code>ruby
Money::Currency.new("USD").exponent  # =&gt; 2
Money::Currency.new("JPY").exponent  # =&gt; 0
Money::Currency.new("MGA").exponent  # =&gt; 1
</code></p>

<h3 id="currency-lookup">Currency Lookup</h3>

<p>To find a given currency by ISO 4217 numeric code (three digits) you can do</p>

<p><code>ruby
Money::Currency.find_by_iso_numeric(978) #=&gt; Money::Currency.new(:eur)
</code></p>

<h2 id="currency-exchange">Currency Exchange</h2>

<p>Exchanging money is performed through an exchange bank object. The default
exchange bank object requires one to manually specify the exchange rate. Here’s
an example of how it works:</p>

<p>```ruby
Money.add_rate(“USD”, “CAD”, 1.24515)
Money.add_rate(“CAD”, “USD”, 0.803115)</p>

<p>Money.us_dollar(100).exchange_to(“CAD”)  # =&gt; Money.from_cents(124, “CAD”)
Money.ca_dollar(100).exchange_to(“USD”)  # =&gt; Money.from_cents(80, “USD”)
```</p>

<p>Comparison and arithmetic operations work as expected:</p>

<p>```ruby
Money.from_cents(1000, “USD”) &lt;=&gt; Money.from_cents(900, “USD”)   # =&gt; 1; 9.00 USD is smaller
Money.from_cents(1000, “EUR”) + Money.from_cents(10, “EUR”) == Money.from_cents(1010, “EUR”)</p>

<p>Money.add_rate(“USD”, “EUR”, 0.5)
Money.from_cents(1000, “EUR”) + Money.from_cents(1000, “USD”) == Money.from_cents(1500, “EUR”)
```</p>

<h3 id="exchange-rate-stores">Exchange rate stores</h3>

<p>The default bank is initialized with an in-memory store for exchange rates.</p>

<p><code>ruby
Money.default_bank = Money::Bank::VariableExchange.new(Money::RatesStore::Memory.new)
</code></p>

<p>You can pass your own store implementation, i.e. for storing and retrieving rates off a database, file, cache, etc.</p>

<p><code>ruby
Money.default_bank = Money::Bank::VariableExchange.new(MyCustomStore.new)
</code></p>

<p>Stores must implement the following interface:</p>

<p>```ruby
# Add new exchange rate.
# @param [String] iso_from Currency ISO code. ex. ‘USD’
# @param [String] iso_to Currency ISO code. ex. ‘CAD’
# @param [Numeric] rate Exchange rate. ex. 0.0016
#
# @return [Numeric] rate.
def add_rate(iso_from, iso_to, rate); end</p>

<h1 id="get-rate-must-be-idempotent-ie-adding-the-same-rate-must-not-produce-duplicates">Get rate. Must be idempotent. i.e. adding the same rate must not produce duplicates.</h1>
<p># @param [String] iso_from Currency ISO code. ex. ‘USD’
# @param [String] iso_to Currency ISO code. ex. ‘CAD’
#
# @return [Numeric] rate.
def get_rate(iso_from, iso_to); end</p>

<h1 id="iterate-over-rate-tuples-isofrom-isoto-rate">Iterate over rate tuples (iso_from, iso_to, rate)</h1>
<p>#
# @yieldparam iso_from [String] Currency ISO string.
# @yieldparam iso_to [String] Currency ISO string.
# @yieldparam rate [Numeric] Exchange rate.
#
# @return [Enumerator]
#
# @example
#   store.each_rate do |iso_from, iso_to, rate|
#     puts [iso_from, iso_to, rate].join
#   end
def each_rate(&amp;block); end</p>

<h1 id="wrap-store-operations-in-a-thread-safe-transaction">Wrap store operations in a thread-safe transaction</h1>
<p># (or IO or Database transaction, depending on your implementation)
#
# @yield [n] Block that will be wrapped in transaction.
#
# @example
#   store.transaction do
#     store.add_rate(‘USD’, ‘CAD’, 0.9)
#     store.add_rate(‘USD’, ‘CLP’, 0.0016)
#   end
def transaction(&amp;block); end</p>

<h1 id="serialize-store-and-its-content-to-make-marshaldump-work">Serialize store and its content to make Marshal.dump work.</h1>
<p>#
# Returns an array with store class and any arguments needed to initialize the store in the current state.</p>

<h1 id="return-array-class-arg1-arg2">@return [Array] [class, arg1, arg2]</h1>
<p>def marshal_dump; end
```</p>

<p>The following example implements an <code>ActiveRecord</code> store to save exchange rates to a database.</p>

<p>```ruby
# rails g model exchange_rate from:string to:string rate:float</p>

<p>class ExchangeRate &lt; ApplicationRecord
  def self.get_rate(from_iso_code, to_iso_code)
    rate = find_by(from: from_iso_code, to: to_iso_code)
    rate&amp;.rate
  end</p>

<p>def self.add_rate(from_iso_code, to_iso_code, rate)
    exrate = find_or_initialize_by(from: from_iso_code, to: to_iso_code)
    exrate.rate = rate
    exrate.save!
  end</p>

<p>def self.each_rate
    return find_each unless block_given?</p>

<pre class="code ruby"><code class="ruby">find_each do |rate|
  yield rate.from, rate.to, rate.rate
end   end
</code></pre>

<p>def self.marshal_dump
    [self]
  end
end
```</p>

<p>The following example implements a <code>Redis</code> store to save exchange rates to a redis database.</p>

<p>```ruby
class RedisRateStore
  INDEX_KEY_SEPARATOR = ‘<em>TO</em>‘.freeze</p>

<p># Using second db of the redis instance
  # because sidekiq uses the first db
  REDIS_DATABASE = 1</p>

<p># Using Hash to store rates data
  REDIS_STORE_KEY = ‘rates’</p>

<p>def initialize
    conn_url = “#Rails.application.credentials.redis_server/#REDIS_DATABASE”
    @connection = Redis.new(url: conn_url)
  end</p>

<p>def add_rate(iso_from, iso_to, rate)
    @connection.hset(REDIS_STORE_KEY, rate_key_for(iso_from, iso_to), rate)
  end</p>

<p>def get_rate(iso_from, iso_to)
    @connection.hget(REDIS_STORE_KEY, rate_key_for(iso_from, iso_to))
  end</p>

<p>def each_rate
    rates = @connection.hgetall(REDIS_STORE_KEY)
    return to_enum(:each_rate) unless block_given?</p>

<pre class="code ruby"><code class="ruby">rates.each do |key, rate|
  iso_from, iso_to = key.split(INDEX_KEY_SEPARATOR)
  yield iso_from, iso_to, rate
end   end
</code></pre>

<p>def transaction
    yield
  end</p>

<p>private</p>

<p>def rate_key_for(iso_from, iso_to)
    [iso_from, iso_to].join(INDEX_KEY_SEPARATOR).upcase
  end
end
```</p>

<p>Now you can use it with the default bank.</p>

<p>```ruby
# For Rails 6 pass model name as a string to make it compatible with zeitwerk
# Money.default_bank = Money::Bank::VariableExchange.new(“ExchangeRate”)
Money.default_bank = Money::Bank::VariableExchange.new(ExchangeRate)</p>

<h1 id="add-to-the-underlying-store">Add to the underlying store</h1>
<p>Money.default_bank.add_rate(‘USD’, ‘CAD’, 0.9)
# Retrieve from the underlying store
Money.default_bank.get_rate(‘USD’, ‘CAD’) # =&gt; 0.9
# Exchanging amounts just works.
Money.from_cents(1000, ‘USD’).exchange_to(‘CAD’) #=&gt; #&lt;Money fractional:900 currency:CAD&gt;
```</p>

<p>There is nothing stopping you from creating store objects which scrapes
<a href="https://www.xe.com">XE</a> for the current rates or just returns <code>rand(2)</code>:</p>

<p><code>ruby
Money.default_bank = Money::Bank::VariableExchange.new(StoreWhichScrapesXeDotCom.new)
</code></p>

<p>You can also implement your own Bank to calculate exchanges differently.
Different banks can share Stores.</p>

<p><code>ruby
Money.default_bank = MyCustomBank.new(Money::RatesStore::Memory.new)
</code></p>

<p>If you wish to disable automatic currency conversion to prevent arithmetic when
currencies don’t match:</p>

<p><code>ruby
Money.disallow_currency_conversion!
</code></p>

<h3 id="implementations">Implementations</h3>

<p>The following is a list of Money.gem compatible currency exchange rate
implementations.</p>

<ul>
  <li><a href="https://github.com/RubyMoney/eu_central_bank">eu_central_bank</a></li>
  <li><a href="https://github.com/RubyMoney/google_currency">google_currency</a></li>
  <li><a href="https://github.com/askuratovsky/currencylayer">currencylayer</a></li>
  <li><a href="https://github.com/matiaskorhonen/nordea">nordea</a></li>
  <li><a href="https://github.com/slbug/nbrb_currency">nbrb_currency</a></li>
  <li><a href="https://github.com/phlegx/money-currencylayer-bank">money-currencylayer-bank</a></li>
  <li><a href="https://github.com/spk/money-open-exchange-rates">money-open-exchange-rates</a></li>
  <li><a href="https://github.com/atwam/money-historical-bank">money-historical-bank</a></li>
  <li><a href="https://github.com/rmustafin/russian_central_bank">russian_central_bank</a></li>
  <li><a href="https://github.com/subvisual/money-uphold-bank">money-uphold-bank</a></li>
</ul>

<h2 id="formatting">Formatting</h2>

<p>There are several formatting rules for when <code>Money#format</code> is called. For more information, check out the <a href="https://github.com/RubyMoney/money/blob/main/lib/money/money/formatter.rb">formatting module source</a>, or read the latest release’s <a href="https://www.rubydoc.info/gems/money/Money/Formatter">rdoc version</a>.</p>

<p>If you wish to format money according to the EU’s <a href="https://style-guide.europa.eu/en/content/-/isg/topic?identifier=7.3.3-rules-for-expressing-monetary-units#id370303__id370303_PositionISO">Rules for expressing monetary units</a> in either English, Irish, Latvian or Maltese:</p>

<p><code>ruby
m = Money.from_cents('123', :gbp) # =&gt; #&lt;Money fractional:123 currency:GBP&gt;
m.format(symbol: m.currency.to_s + ' ') # =&gt; "GBP 1.23"
</code></p>

<h2 id="rounding">Rounding</h2>

<p>By default, <code>Money</code> objects are rounded to the nearest cent and the additional precision is not preserved:</p>

<p><code>ruby
Money.from_amount(2.34567).format #=&gt; "$2.35"
</code></p>

<p>To retain the additional precision, you will also need to set <code>infinite_precision</code> to <code>true</code>.</p>

<p><code>ruby
Money.default_infinite_precision = true
Money.from_amount(2.34567).format #=&gt; "$2.34567"
</code></p>

<p>To round to the nearest cent (or anything more precise), you can use the <code>round</code> method. However, note that the <code>round</code> method on a <code>Money</code> object does not work the same way as a normal Ruby <code>Float</code> object. Money’s <code>round</code> method accepts different arguments. The first argument to the round method is the rounding mode, while the second argument is the level of precision relative to the cent.</p>

<p>```ruby
# Float
2.34567.round     #=&gt; 2
2.34567.round(2)  #=&gt; 2.35</p>

<h1 id="money">Money</h1>
<p>Money.default_infinite_precision = true
Money.from_cents(2.34567).format #=&gt; “$0.0234567”
Money.from_cents(2.34567).round.format #=&gt; “$0.02”
Money.from_cents(2.34567).round(BigDecimal::ROUND_DOWN, 2).format #=&gt; “$0.0234”
```</p>

<p>You can set the default rounding mode by passing one of the <code>BigDecimal</code> mode enumerables like so:</p>

<p><code>ruby
Money.rounding_mode = BigDecimal::ROUND_HALF_EVEN
</code></p>

<p>See <a href="https://ruby-doc.org/3.4.1/gems/bigdecimal/BigDecimal.html#ROUND_MODE">BigDecimal::ROUND_MODE</a> for more information.</p>

<p>To round to the nearest cash value in currencies without small denominations:</p>

<p><code>ruby
Money.from_cents(11_11, "CHF").to_nearest_cash_value.format # =&gt; "CHF 11.10"
</code></p>

<h2 id="ruby-on-rails">Ruby on Rails</h2>

<p>To integrate money in a Rails application use <a href="https://github.com/RubyMoney/money-rails">money-rails</a>.</p>

<p>For deprecated methods of integrating with Rails, check <a href="https://github.com/RubyMoney/money/wiki">the wiki</a>.</p>

<h2 id="localization">Localization</h2>

<p>In order to localize formatting you can use <code>I18n</code> gem:</p>

<p><code>ruby
Money.locale_backend = :i18n
</code></p>

<p>With this enabled a thousands separator and a decimal mark will get looked up in your <code>I18n</code> translation files. In a Rails application this may look like:</p>

<p><code>yml
# config/locale/en.yml
en:
  number:
    currency:
      format:
        delimiter: ","
        separator: "."
  # falling back to
  number:
    format:
      delimiter: ","
      separator: "."
</code></p>

<p>For this example <code>Money.from_cents(123456789, "SEK").format</code> will return <code>1,234,567.89
kr</code> which otherwise would have returned <code>1 234 567,89 kr</code>.</p>

<p>This will work seamlessly with <a href="https://github.com/svenfuchs/rails-i18n">rails-i18n</a> gem that already has a lot of locales defined.</p>

<p>If you wish to disable this feature and use defaults instead:</p>

<p><code>ruby
Money.locale_backend = nil
</code></p>

<h3 id="deprecation">Deprecation</h3>

<p>The current default behaviour always checks the I18n locale first, falling back to “per currency”
localization. This is now deprecated and will be removed in favour of explicitly defined behaviour
in the next major release.</p>

<p>If you would like to use I18n localization (formatting depends on the locale):</p>

<p>```ruby
Money.locale_backend = :i18n</p>

<h1 id="example-using-default-localization-from-rails-i18n">example (using default localization from rails-i18n):</h1>
<p>I18n.locale = :en
Money.from_cents(10_000_00, ‘USD’).format # =&gt; $10,000.00
Money.from_cents(10_000_00, ‘EUR’).format # =&gt; €10,000.00</p>

<p>I18n.locale = :es
Money.from_cents(10_000_00, ‘USD’).format # =&gt; $10.000,00
Money.from_cents(10_000_00, ‘EUR’).format # =&gt; €10.000,00
```</p>

<p>If you need to localize the position of the currency symbol, you
have to pass it manually. <em>Note: this will become the default formatting
behavior in the next version.</em></p>

<p><code>ruby
I18n.locale = :fr
format = I18n.t :format, scope: 'number.currency.format'
Money.from_cents(10_00, 'EUR').format(format: format) # =&gt; 10,00 €
</code></p>

<p>For the legacy behaviour of “per currency” localization (formatting depends only on currency):</p>

<p>```ruby
Money.locale_backend = :currency</p>

<h1 id="example">example:</h1>
<p>Money.from_cents(10_000_00, ‘USD’).format # =&gt; $10,000.00
Money.from_cents(10_000_00, ‘EUR’).format # =&gt; €10.000,00
```</p>

<p>In case you don’t need localization and would like to use default values (can be redefined using
<code>Money.default_formatting_rules</code>):</p>

<p>```ruby
Money.locale_backend = nil</p>

<h1 id="example-1">example:</h1>
<p>Money.from_cents(10_000_00, ‘USD’).format # =&gt; $10000.00
Money.from_cents(10_000_00, ‘EUR’).format # =&gt; €10000.00
```</p>

<h2 id="collection">Collection</h2>

<p>In case you’re working with collections of <code>Money</code> instances, have a look at <a href="https://github.com/RubyMoney/money-collection">money-collection</a>
for improved performance and accuracy.</p>

<h3 id="troubleshooting">Troubleshooting</h3>

<p>If you don’t have some locale and don’t want to get a runtime error such as:</p>

<pre class="code ruby"><code class="ruby">I18n::InvalidLocale: :en is not a valid locale
</code></pre>

<p>Set the following:
<code>ruby
I18n.enforce_available_locales = false
</code></p>

<h2 id="heuristics">Heuristics</h2>

<p>Prior to v6.9.0 heuristic analysis of string input was part of this gem. Since then it was extracted in to <a href="https://github.com/RubyMoney/money-heuristics">money-heuristics gem</a>.</p>

<h2 id="migration-notes">Migration Notes</h2>

<h4 id="version-600">Version 6.0.0</h4>

<ul>
  <li>The <code>Money#dollars</code> and <code>Money#amount</code> methods now return instances of
<code>BigDecimal</code> rather than <code>Float</code>. We should avoid representing monetary
values with floating point types so to avoid a whole class of errors relating
to lack of precision. There are two migration options for this change:
    <ul>
      <li>The first is to test your application and where applicable update the
application to accept a <code>BigDecimal</code> return value. This is the recommended
path.</li>
      <li>The second is to migrate from the <code>#amount</code> and <code>#dollars</code> methods to use
the <code>#to_f</code> method instead. This option should only be used where <code>Float</code>
is the desired type and nothing else will do for your application’s
requirements.</li>
    </ul>
  </li>
</ul>
</div></div>

      <div id="footer">
  Generated on Thu Jul 24 12:16:16 2025 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.37 (ruby-3.4.5).
</div>

    </div>
  </body>
</html>
